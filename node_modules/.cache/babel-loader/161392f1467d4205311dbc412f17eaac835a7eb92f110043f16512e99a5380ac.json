{"ast":null,"code":"import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-2b7e2072.development.esm.js';\nimport '../../dev/dist/xstate-dev.development.esm.js';\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and received `event` object as arguments, and returns the next state, similar to a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial state argument, and is not the same as the State object of an actor or a state within a machine configuration.\n *\n * @param transition The transition function used to describe the transition logic. It should return the next state given the current state and event. It receives the following arguments:\n * - `state` - the current state.\n * - `event` - the received event.\n * - `actorScope` - the actor scope object, with properties like `self` and `system`.\n * @param initialContext The initial state of the transition function, either an object representing the state, or a function which returns a state object. If a function, it will receive as its only argument an object with the following properties:\n * - `input` - the `input` provided to its parent transition actor.\n * - `self` - a reference to its parent transition actor.\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n * @returns Actor logic\n *\n * @example\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1,\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 },\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\nconst instanceStates = /* #__PURE__ */new WeakMap();\n/**\n * An actor logic creator which returns callback logic as defined by a callback function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @param invokeCallback - The callback function used to describe the callback logic\n * The callback function is passed an object with the following properties:\n * - `receive` - A function that can send events back to the parent actor; the listener is then called whenever events are received by the callback actor\n * - `sendBack` - A function that can send events back to the parent actor\n * - `input` - Data that was provided to the callback actor\n * - `self` - The parent actor of the callback actor\n * - `system` - The actor system to which the callback actor belongs\n * The callback function can (optionally) return a cleanup function, which is called when the actor is stopped.\n * @see {@link InvokeCallback} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n\n * @returns Callback logic\n *\n * @example\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n */\nfunction fromCallback(invokeCallback) {\n  const logic = {\n    config: invokeCallback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = invokeCallback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        }\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n/**\n * Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @param observableCreator A function that creates an observable. It receives one argument, an object with the following properties:\n * - `input` - Data that was provided to the observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the observable actor belongs\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import { fromObservable, createActor } from 'xstate'\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event, {\n      self,\n      id,\n      defer,\n      system\n    }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers event objects.\n *\n * Event observable actor logic is described by an observable stream of {@link https://stately.ai/docs/transitions#event-objects | event objects}. Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @param lazyObservable A function that creates an observable that delivers event objects. It receives one argument, an object with the following properties:\n *\n * - `input` - Data that was provided to the event observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the event observable actor belongs.\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(() =>\n *   fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic,\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n/**\n * An actor logic creator which returns promise logic as defined by an async process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @param promiseCreator\n *   A function which returns a Promise, and accepts an object with the following properties:\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n *\n * @example\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...')\n *     .then((data) => data.json());\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n */\n\nconst controllerMap = new WeakMap();\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };","map":{"version":3,"names":["X","XSTATE_STOP","A","createActor","fromTransition","transition","initialContext","config","snapshot","event","actorScope","context","getInitialSnapshot","_","input","status","output","undefined","error","getPersistedSnapshot","restoreSnapshot","instanceStates","WeakMap","fromCallback","invokeCallback","logic","start","state","self","system","callbackState","receivers","dispose","set","sendBack","getSnapshot","_parent","_relay","receive","listener","Set","add","get","type","forEach","receiver","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","fromObservable","observableCreator","id","defer","newSnapshot","data","_subscription","unsubscribe","subscribe","next","value","err","complete","fromEventObservable","lazyObservable","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","fromPromise","promiseCreator","scope","resolvedValue","abort","controller","AbortController","resolvedPromise","Promise","resolve","signal","then","response","delete","errorData","emptyLogic","createEmptyActor"],"sources":["C:/PoC-FE/video-fsm-uno/node_modules/xstate/actors/dist/xstate-actors.development.esm.js"],"sourcesContent":["import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-2b7e2072.development.esm.js';\nimport '../../dev/dist/xstate-dev.development.esm.js';\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and received `event` object as arguments, and returns the next state, similar to a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial state argument, and is not the same as the State object of an actor or a state within a machine configuration.\n *\n * @param transition The transition function used to describe the transition logic. It should return the next state given the current state and event. It receives the following arguments:\n * - `state` - the current state.\n * - `event` - the received event.\n * - `actorScope` - the actor scope object, with properties like `self` and `system`.\n * @param initialContext The initial state of the transition function, either an object representing the state, or a function which returns a state object. If a function, it will receive as its only argument an object with the following properties:\n * - `input` - the `input` provided to its parent transition actor.\n * - `self` - a reference to its parent transition actor.\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n * @returns Actor logic\n *\n * @example\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1,\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 },\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n/**\n * An actor logic creator which returns callback logic as defined by a callback function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @param invokeCallback - The callback function used to describe the callback logic\n * The callback function is passed an object with the following properties:\n * - `receive` - A function that can send events back to the parent actor; the listener is then called whenever events are received by the callback actor\n * - `sendBack` - A function that can send events back to the parent actor\n * - `input` - Data that was provided to the callback actor\n * - `self` - The parent actor of the callback actor\n * - `system` - The actor system to which the callback actor belongs\n * The callback function can (optionally) return a cleanup function, which is called when the actor is stopped.\n * @see {@link InvokeCallback} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n\n * @returns Callback logic\n *\n * @example\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n */\nfunction fromCallback(invokeCallback) {\n  const logic = {\n    config: invokeCallback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = invokeCallback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        }\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n/**\n * Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @param observableCreator A function that creates an observable. It receives one argument, an object with the following properties:\n * - `input` - Data that was provided to the observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the observable actor belongs\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import { fromObservable, createActor } from 'xstate'\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event, {\n      self,\n      id,\n      defer,\n      system\n    }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers event objects.\n *\n * Event observable actor logic is described by an observable stream of {@link https://stately.ai/docs/transitions#event-objects | event objects}. Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @param lazyObservable A function that creates an observable that delivers event objects. It receives one argument, an object with the following properties:\n *\n * - `input` - Data that was provided to the event observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the event observable actor belongs.\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(() =>\n *   fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic,\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n/**\n * An actor logic creator which returns promise logic as defined by an async process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @param promiseCreator\n *   A function which returns a Promise, and accepts an object with the following properties:\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n *\n * @example\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...')\n *     .then((data) => data.json());\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n */\n\nconst controllerMap = new WeakMap();\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\n\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,WAAW,QAAQ,8CAA8C;AACjG,OAAO,8CAA8C;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,UAAU,EAAEC,cAAc,EAAE;EAClD,OAAO;IACLC,MAAM,EAAEF,UAAU;IAClBA,UAAU,EAAEA,CAACG,QAAQ,EAAEC,KAAK,EAAEC,UAAU,KAAK;MAC3C,OAAO;QACL,GAAGF,QAAQ;QACXG,OAAO,EAAEN,UAAU,CAACG,QAAQ,CAACG,OAAO,EAAEF,KAAK,EAAEC,UAAU;MACzD,CAAC;IACH,CAAC;IACDE,kBAAkB,EAAEA,CAACC,CAAC,EAAEC,KAAK,KAAK;MAChC,OAAO;QACLC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEC,SAAS;QACjBC,KAAK,EAAED,SAAS;QAChBN,OAAO,EAAE,OAAOL,cAAc,KAAK,UAAU,GAAGA,cAAc,CAAC;UAC7DQ;QACF,CAAC,CAAC,GAAGR;MACP,CAAC;IACH,CAAC;IACDa,oBAAoB,EAAEX,QAAQ,IAAIA,QAAQ;IAC1CY,eAAe,EAAEZ,QAAQ,IAAIA;EAC/B,CAAC;AACH;AAEA,MAAMa,cAAc,GAAG,eAAe,IAAIC,OAAO,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}