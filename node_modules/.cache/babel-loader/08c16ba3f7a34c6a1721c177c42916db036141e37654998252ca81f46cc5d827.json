{"ast":null,"code":"export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.development.esm.js';\nimport { S as STATE_DELIMITER, m as mapValues, t as toArray, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-2b7e2072.development.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, E as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, D as isMachineSnapshot, J as matchesState, F as not, G as or, K as pathToStateValue, O as raise, P as spawnChild, H as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-2b7e2072.development.esm.js';\nimport { a as assign } from './log-bbab35a7.development.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-bbab35a7.development.esm.js';\nimport '../dev/dist/xstate-dev.development.esm.js';\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     */\n    this.key = void 0;\n    /**\n     * The unique ID of the state node.\n     */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    this.type = void 0;\n    /**\n     * The string path from the root machine node to this node.\n     */\n    this.path = void 0;\n    /**\n     * The child state nodes.\n     */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     *  - `'shallow'` - recalls only top-level historical state value\n     *  - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    this.entry = void 0;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    this.exit = void 0;\n    /**\n     * The parent state node.\n     */\n    this.parent = void 0;\n    /**\n     * The root machine node.\n     */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /**\n   * The well-structured state node definition.\n   */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /**\n   * The logic invoked as actors by this state node.\n   */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /**\n   * The mapping of events to transitions.\n   */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /**\n   * All the event types accepted by this state node and its descendants.\n   */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, implementations) {\n    this.config = config;\n    /**\n     * The machine's own version.\n     */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    /**\n     * @deprecated an internal property that was acting as a \"phantom\" type, it's not used by anything right now but it's kept around for compatibility reasons\n     **/\n    this.__TResolvedTypesMeta = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n    if (!('output' in this.root) && Object.values(this.states).some(state => state.type === 'final' && 'output' in state)) {\n      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations\n   * and merges the `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)\n   *  to recursively merge with the existing options.\n   *\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received `event`.\n   * Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`.\n   * Calculates a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps.\n   * This \"pre-initial\" state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy\n * a predicate, and then resolves with that value.\n * Will throw if the desired state is not reached after an optional timeout.\n * (defaults to Infinity).\n *\n * @example\n * ```js\n * const state = await waitFor(someService, state => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value\n * that matches the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    let done = false;\n    if (resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      sub.unsubscribe();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })` to provide machine implementations instead.\n *\n * @example\n  ```ts\n  import { createMachine } from 'xstate';\n\n  const lightMachine = createMachine({\n    id: 'light',\n    initial: 'green',\n    states: {\n      green: {\n        on: {\n          TIMER: { target: 'yellow' }\n        }\n      },\n      yellow: {\n        on: {\n          TIMER: { target: 'red' }\n        }\n      },\n      red: {\n        on: {\n          TIMER: { target: 'green' }\n        }\n      }\n    }\n  });\n\n  const lightActor = createActor(lightMachine);\n  lightActor.start();\n\n  lightActor.send({ type: 'TIMER' });\n  ```\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on\n * the given `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the\n * `actorLogic` is used.\n *\n * @example\n  ```ts\n  import { getNextSnapshot } from 'xstate';\n  import { trafficLightMachine } from './trafficLightMachine.ts';\n\n  const nextSnapshot = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    undefined, // snapshot (or initial state if undefined)\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot.value);\n  // => 'yellow'\n\n  const nextSnapshot2 = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    nextSnapshot, // snapshot\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot2.value);\n  // =>'red'\n  ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Asserts that the given event object is of the specified type or types.\n * Throws an error if the event object is not of the specified types.\n  @example\n\n  ```ts\n  // ...\n  entry: ({ event }) => {\n    assertEvent(event, 'doNothing');\n    // event is { type: 'doNothing' }\n  },\n  // ...\n  exit: ({ event }) => {\n    assertEvent(event, 'greet');\n    // event is { type: 'greet'; message: string }\n\n    assertEvent(event, ['greet', 'notify']);\n    // event is { type: 'greet'; message: string }\n    // or { type: 'notify'; message: string; level: 'info' | 'error' }\n  },\n  ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };","map":{"version":3,"names":["createEmptyActor","fromCallback","fromEventObservable","fromObservable","fromPromise","fromTransition","S","STATE_DELIMITER","m","mapValues","t","toArray","f","formatTransitions","a","toTransitionConfigArray","b","formatTransition","N","NULL_EVENT","e","evaluateGuard","c","createInvokeId","g","getDelayedTransitions","d","formatInitialTransition","h","getCandidates","r","resolveStateValue","i","getAllStateNodes","j","getStateNodes","k","createMachineSnapshot","l","isInFinalState","n","macrostep","o","transitionNode","p","resolveActionsAndContext","q","createInitEvent","s","microstep","u","getInitialStateNodes","v","toStatePath","w","isStateId","x","getStateNodeByPath","y","getPersistedSnapshot","z","resolveReferencedActor","A","createActor","$","$$ACTOR_TYPE","B","Actor","I","__unsafe_getAllOwnEventDescriptors","E","and","M","cancel","C","interpret","D","isMachineSnapshot","J","matchesState","F","not","G","or","K","pathToStateValue","O","raise","P","spawnChild","H","stateIn","Q","stop","R","stopChild","L","toObserver","assign","SpecialTargets","emit","enqueueActions","forwardTo","log","sendParent","sendTo","SimulatedClock","constructor","timeouts","Map","_now","_id","_flushing","_flushingInvalidated","now","getId","setTimeout","fn","timeout","id","set","start","clearTimeout","delete","time","Error","flushTimeouts","sorted","sort","_idA","timeoutA","_idB","timeoutB","endA","endB","call","increment","ms","cache","WeakMap","memo","object","key","memoizedData","get","EMPTY_OBJECT","toSerializableAction","action","type","name","StateNode","config","options","path","states","history","entry","exit","parent","machine","meta","output","order","description","tags","transitions","always","_parent","_key","_machine","concat","join","Object","keys","length","idMap","size","stateConfig","stateNode","initial","slice","undefined","_initialize","map","forEach","definition","version","target","source","actions","eventType","reenter","toJSON","state","on","values","flat","invoke","invokeConfig","src","systemId","resolvedId","resolvedSrc","onDone","onError","invokeDefValues","flatMap","descriptor","reduce","transition","push","after","next","snapshot","event","selectedTransition","candidates","candidate","guard","resolvedContext","context","guardPassed","err","guardType","message","events","Set","ownEvents","stateId","add","Array","from","filter","some","STATE_IDENTIFIER","StateMachine","implementations","schemas","__xstatenode","root","__TResolvedTypesMeta","actors","delays","guards","bind","getInitialSnapshot","restoreSnapshot","console","warn","provide","resolveState","resolvedStateValue","value","nodeSet","_nodes","children","status","error","historyValue","actorScope","microstates","getTransitionData","getPreInitialState","initEvent","internalQueue","preInitial","assignment","spawn","self","input","preInitialState","nextState","macroState","child","getSnapshot","getStateNodeById","fullPath","relativePath","resolvedStateId","_actorScope","snapshotChildren","actorId","actorData","childState","logic","actorRef","syncSnapshot","restoredSnapshot","seen","reviveContext","contextPart","has","xstate$$type","defaultWaitForOptions","Infinity","waitFor","predicate","resolvedOptions","Promise","res","rej","done","handle","sub","unsubscribe","dispose","checkEmitted","emitted","subscribe","complete","createMachine","createInertActorScope","actorLogic","inertActorScope","defer","logger","sessionId","system","getNextSnapshot","_snapshot","setup","toPromise","actor","resolve","reject","assertEvent","types","includes","typesText","JSON","stringify"],"sources":["C:/PoC-FE/video-fsm-uno/node_modules/xstate/dist/xstate.development.esm.js"],"sourcesContent":["export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.development.esm.js';\nimport { S as STATE_DELIMITER, m as mapValues, t as toArray, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-2b7e2072.development.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, E as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, D as isMachineSnapshot, J as matchesState, F as not, G as or, K as pathToStateValue, O as raise, P as spawnChild, H as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-2b7e2072.development.esm.js';\nimport { a as assign } from './log-bbab35a7.development.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-bbab35a7.development.esm.js';\nimport '../dev/dist/xstate-dev.development.esm.js';\n\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     */\n    this.key = void 0;\n    /**\n     * The unique ID of the state node.\n     */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    this.type = void 0;\n    /**\n     * The string path from the root machine node to this node.\n     */\n    this.path = void 0;\n    /**\n     * The child state nodes.\n     */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     *  - `'shallow'` - recalls only top-level historical state value\n     *  - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    this.entry = void 0;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    this.exit = void 0;\n    /**\n     * The parent state node.\n     */\n    this.parent = void 0;\n    /**\n     * The root machine node.\n     */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /**\n   * The well-structured state node definition.\n   */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /**\n   * The logic invoked as actors by this state node.\n   */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /**\n   * The mapping of events to transitions.\n   */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /**\n   * All the event types accepted by this state node and its descendants.\n   */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, implementations) {\n    this.config = config;\n    /**\n     * The machine's own version.\n     */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    /**\n     * @deprecated an internal property that was acting as a \"phantom\" type, it's not used by anything right now but it's kept around for compatibility reasons\n     **/\n    this.__TResolvedTypesMeta = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n    if (!('output' in this.root) && Object.values(this.states).some(state => state.type === 'final' && 'output' in state)) {\n      console.warn('Missing `machine.output` declaration (top-level final state with output detected)');\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations\n   * and merges the `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)\n   *  to recursively merge with the existing options.\n   *\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received `event`.\n   * Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`.\n   * Calculates a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps.\n   * This \"pre-initial\" state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy\n * a predicate, and then resolves with that value.\n * Will throw if the desired state is not reached after an optional timeout.\n * (defaults to Infinity).\n *\n * @example\n * ```js\n * const state = await waitFor(someService, state => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value\n * that matches the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    let done = false;\n    if (resolvedOptions.timeout < 0) {\n      console.error('`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.');\n    }\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      sub.unsubscribe();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })` to provide machine implementations instead.\n *\n * @example\n  ```ts\n  import { createMachine } from 'xstate';\n\n  const lightMachine = createMachine({\n    id: 'light',\n    initial: 'green',\n    states: {\n      green: {\n        on: {\n          TIMER: { target: 'yellow' }\n        }\n      },\n      yellow: {\n        on: {\n          TIMER: { target: 'red' }\n        }\n      },\n      red: {\n        on: {\n          TIMER: { target: 'green' }\n        }\n      }\n    }\n  });\n\n  const lightActor = createActor(lightMachine);\n  lightActor.start();\n\n  lightActor.send({ type: 'TIMER' });\n  ```\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on\n * the given `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the\n * `actorLogic` is used.\n *\n * @example\n  ```ts\n  import { getNextSnapshot } from 'xstate';\n  import { trafficLightMachine } from './trafficLightMachine.ts';\n\n  const nextSnapshot = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    undefined, // snapshot (or initial state if undefined)\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot.value);\n  // => 'yellow'\n\n  const nextSnapshot2 = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    nextSnapshot, // snapshot\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot2.value);\n  // =>'red'\n  ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Asserts that the given event object is of the specified type or types.\n * Throws an error if the event object is not of the specified types.\n  @example\n\n  ```ts\n  // ...\n  entry: ({ event }) => {\n    assertEvent(event, 'doNothing');\n    // event is { type: 'doNothing' }\n  },\n  // ...\n  exit: ({ event }) => {\n    assertEvent(event, 'greet');\n    // event is { type: 'greet'; message: string }\n\n    assertEvent(event, ['greet', 'notify']);\n    // event is { type: 'greet'; message: string }\n    // or { type: 'notify'; message: string; level: 'info' | 'error' }\n  },\n  ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}