{"ast":null,"code":"import { __assign, __read } from './_virtual/_tslib.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { toSCXMLEvent, isFunction, toEventObject, getEventType, isString, partition, updateContext, flatten, toArray, toGuard, evaluateGuard, warn, isArray } from './utils.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { send as send$1, update, assign as assign$1, init, raise as raise$1, log as log$1, cancel as cancel$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n  Object.defineProperty(actionObject, 'toString', {\n    value: function () {\n      return actionObject.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n  return {\n    type: raise$1,\n    event: event\n  };\n}\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\" + id : '';\n  return ActionTypes.After + \"(\" + delayRef + \")\" + idSuffix;\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = ActionTypes.DoneState + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = ActionTypes.DoneInvoke + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = ActionTypes.ErrorPlatform + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n  eventObject.toString = function () {\n    return type;\n  };\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\nfunction resolveActions(machine, currentState, currentContext, _event, actions) {\n  var _a = __read(partition(actions, function (action) {\n      return action.type === assign$1;\n    }), 2),\n    assignActions = _a[0],\n    otherActions = _a[1];\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var resolvedActions = flatten(otherActions.map(function (actionObject) {\n    var _a;\n    switch (actionObject.type) {\n      case raise$1:\n        return resolveRaise(actionObject);\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number',\n          // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + machine.id + \"'\");\n        }\n        return sendAction;\n      case log$1:\n        return resolveLog(actionObject, updatedContext, _event);\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n          if (!matchedActions) {\n            return [];\n          }\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n          if (!matchedActions) {\n            return [];\n          }\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n      case stop$1:\n        {\n          return resolveStop(actionObject, updatedContext, _event);\n        }\n      default:\n        return toActionObject(actionObject, machine.options.actions);\n    }\n  }));\n  return [resolvedActions, updatedContext];\n}\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };","map":{"version":3,"names":["__assign","__read","IS_PRODUCTION","toSCXMLEvent","isFunction","toEventObject","getEventType","isString","partition","updateContext","flatten","toArray","toGuard","evaluateGuard","warn","isArray","SpecialTargets","ActionTypes","send","send$1","update","assign","assign$1","init","raise","raise$1","log","log$1","cancel","cancel$1","error","error$1","stop","stop$1","pure","pure$1","choose","choose$1","initEvent","type","getActionFunction","actionType","actionFunctionMap","undefined","toActionObject","action","actionObject","exec","name","toString","Object","defineProperty","value","enumerable","configurable","toActionObjects","actions","map","subAction","toActivityDefinition","id","event","to","Internal","resolveRaise","_event","options","delay","resolveSend","ctx","delaysMap","meta","resolvedEvent","data","resolvedDelay","configDelay","resolvedTarget","sendParent","Parent","sendUpdate","respond","_","__","_a","origin","defaultLogExpr","context","expr","label","resolveLog","sendId","start","activity","activityDef","Start","actorRef","Stop","resolveStop","actorRefOrString","resolvedActorRef","assignment","after","delayRef","idSuffix","After","done","DoneState","eventObject","doneInvoke","DoneInvoke","ErrorPlatform","getActions","Pure","get","forwardTo","target","escalate","errorData","conds","Choose","resolveActions","machine","currentState","currentContext","assignActions","otherActions","updatedContext","length","resolvedActions","sendAction","delays","chooseAction","matchedActions","find","condition","guard","cond","guards","resolved"],"sources":["C:/PoC-FE/video-fsm-uno/node_modules/xstate/es/actions.js"],"sourcesContent":["import { __assign, __read } from './_virtual/_tslib.js';\nimport { IS_PRODUCTION } from './environment.js';\nimport { toSCXMLEvent, isFunction, toEventObject, getEventType, isString, partition, updateContext, flatten, toArray, toGuard, evaluateGuard, warn, isArray } from './utils.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { send as send$1, update, assign as assign$1, init, raise as raise$1, log as log$1, cancel as cancel$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\n\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\n\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  Object.defineProperty(actionObject, 'toString', {\n    value: function () {\n      return actionObject.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return actionObject;\n}\n\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\n\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\n\nfunction raise(event) {\n  if (!isString(event)) {\n    return send(event, {\n      to: SpecialTargets.Internal\n    });\n  }\n\n  return {\n    type: raise$1,\n    event: event\n  };\n}\n\nfunction resolveRaise(action) {\n  return {\n    type: raise$1,\n    _event: toSCXMLEvent(action.event)\n  };\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\n\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\n\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\n\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\" + id : '';\n  return ActionTypes.After + \"(\" + delayRef + \")\" + idSuffix;\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction done(id, data) {\n  var type = ActionTypes.DoneState + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction doneInvoke(id, data) {\n  var type = ActionTypes.DoneInvoke + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction error(id, data) {\n  var type = ActionTypes.ErrorPlatform + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction forwardTo(target, options) {\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nfunction resolveActions(machine, currentState, currentContext, _event, actions) {\n  var _a = __read(partition(actions, function (action) {\n    return action.type === assign$1;\n  }), 2),\n      assignActions = _a[0],\n      otherActions = _a[1];\n\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var resolvedActions = flatten(otherActions.map(function (actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        return resolveRaise(actionObject);\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          warn(!isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + machine.id + \"'\");\n        }\n\n        return sendAction;\n\n      case log$1:\n        return resolveLog(actionObject, updatedContext, _event);\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case stop$1:\n        {\n          return resolveStop(actionObject, updatedContext, _event);\n        }\n\n      default:\n        return toActionObject(actionObject, machine.options.actions);\n    }\n  }));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}